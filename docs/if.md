# If

Rustの`if`は特に難しいところはありません。しかし、従来のシステムプログラミング言語よりは動的な型付け言語に近いです。  
それでは、これがどういうことなのか理解するために、話を始めましょう。　　

`if`とは分岐をより一般的にな形にしたものです。  
ある点で選択をし、それぞれの道に別れることができます。  

下の`if`の場合は、ひとつの選択があり、２つの道に分かれています。  

    let x = 5;

    if x == 5 {
        println!("x is five!");
    }

もし`x`の値を他の何かに変更したら、`x is five!`という文字列は出力されません。更に詳しく言うと、  
`if`のあとの式が`true`になると、そのブロックは実行されます。もし`false`の場合は実行されません。  

もし`false`の場合にも何か実行したい場合は`else`を使ってください。  

    let x = 5;

    if x == 5 {
        println!("x is five!");
    } else {
        println!("x is not five :(");
    }

これは一般的な例ですが、次のようなこともできます。  

    let x = 5;

    let y = if x == 5 {
        10
    } else {
        15
    }; // y: i32  


この例からは、Rustについての２つの興味深いことがわかります。  
Rustが式指向言語だということ、そして、セミコロンが他の波括弧とセミコロンを使用する言語のものと違うということです。  
この２つのことは関係しています。  

## 式(Expression) vs 文(Statement)

Rustは式ベースの言語を主としています。２種類のステートメントが存在し、それ以外はすべて式です。  

それではこの２つの違いは何でしょうか。  

式は値を返しますが、ステートメントは返しません。  
多くの言語では`if`はステートメントですので、`let x = if ...`のようなことはできません。  
しかし`Rust`では`if`は式です。つまり値を返すということです。  
この値を変数の初期化に使用することもできます。  

そういえば、割り当て(バインディング)はRustの持っているステートメント２種類のうちの１つです。  
正しい名前は`宣言文(declaration statement)`です。  
これまで、`let`は私達が見てきた中で唯一の宣言文でした。  
この事についてもう少し話しましょう。  

いくつかの言語では、変数割り当てはステートメントではなく、式として書くことができます。  
Rubyのようにです。  

    x = y = 5

しかし、Rustでは、`let`を使ってバインディングを行うのは式ではありません。  
エラーを起こしていまいます。  

    let x = (let y = 5); // expected identifier, found keyword `let`

コンパイラが式の先頭を見て、期待しているものを教えてくれています。  
`let`はステートメントの始まりであり、式ではありません。  

注意して欲しいのが、すでに割り当てられた変数への代入(例えば`y = 5`)は式だということです。  
その値は特に有用ではありませんが。  
Cとは違い、割り当てられた値に割り当てを行おうとしている場所(前の例の`5`等)では、割り当てる値がユニット型`()`です。  
(これについてはあとで触れます)  

Rustの２つ目のステートメントは式ステートメントです。これを利用する目的は任意の式をステートメントで有効にすることです。  
実用的な面から、Rustの文法ではステートメントに他のステートメントが続くように考えられています。  
どういうことかというと、式を他のものから分離させるためにセミコロンを使うということです。  
Rustでは他の言語のようにほとんどの行の終わりにセミコロンを使います。  
Rustのコードの行の終わりがセミコロンになっているのを見てきているはずです。  

ほとんどと言っているので、それ以外が何か気になりますよね？  
実はすでに見ていますよ。次のようなコードです。

    let x = 5;

    let y: i32 = if x == 5 { 10 } else { 15 };

`y`を整数型にするため型アノテーションを追加しています。  

これは次のコードとは違います。こちらの場合はコンパイルが出来ません。  

    let x = 5;

    let y: i32 = if x == 5 { 10; } else { 15; };

**10** と　**15** の後ろにセミコロンがついています。  
Rustは次のようなエラーを出力します。

    error: mismatched types: expected `i32`, found `()` (expected i32, found())

整数型を期待しているのに実際は`()`だったということです。`()`は`ユニット(unit)`と呼ばれ、  
Rustの型システムの中で特殊な型として存在しています。Rustでは`()`は`i32`に対する有効な値ではありません。  
`()`は`()`に対してのみ有効ですが、特に使われることはないでしょう。  
私たちが、ステートメントは値を返さないと言ったのを覚えていますか？ユニットはその目的のためのものです。  
セミコロンをつけることで式がステートメントになり、あたりの代わりにユニットが返されます。  

セミコロンが末尾につかないコードをもう一つ見たことがあるはずです。  
それは次の`関数(function)`で扱います。